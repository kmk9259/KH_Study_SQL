--DDL(CREATE TABLE ) 및 제약조건

--DDL(DATA DEFINITION LANGUAGE) : 데이터 정의  언어
--객체(OBJECT) 를 만들고 (CREATE) , 수정(ALTER) 하고 삭제(DROP)하는 구문

--오라클에서의 객체 
--테이블 (TABLE), 뷰(VIEW), 시퀀스(SEQUENCE) , 인덱스(INDEX)
--패키지 (PACKAGE), 트리거(TRIGGER), 동의어(SYNONYM),
--프로시져(PROCEDURE), 함수(FUNCTION), 사용자 (USER)

--테이블 만들기 
--[표현식] :
--CREATE TABLE 테이블명(컬럼명 자료형(크기) , 컬럼명 자료형(크기)....);

CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
);
SELECT * FROM MEMBER;
--컬럼에 주석달기
--[표현식]
--COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';

--테이블의 정보
SELECT * FROM SYS.USER_TABLES;

--테이블 내 컬럼정보
SELECT *
FROM SYS.USER_TAB_COLUMNS
WHERE TABLE_NAME='MEMBER';

--제약조건 
-- 테이블작성시 각 컬럼에 대해 값 기록에 대한 제약조건을 설정할수 있다. 
-- 데이터 무결성 보장을 목적으로함 
-- 입력 / 수정 하는 데이터에 문제가 없는지 자동으로 검사하는 목적
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY


-- 제약조건정보확인
--테이블의 제약조건 검색
SELECT *
FROM SYS.USER_CONSTRAINTS;

--컬럼의 제약조건 검색
SELECT *
FROM SYS.USER_CONS_COLUMNS;

--NOT NULL : 해당 컬럼에 반드시 값을 기록해야하는 경우 사용
    --      삽입/수정시 NULL값을 허용하지 않도록 '컬럼레벨에서 제한'

CREATE TABLE USER_NOCONS(
    USER_NO NUMBER,
    USER_ID VARCHAR2 (20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOCONS
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_NOCONS
    VALUES
    (2,null,null,null,null,'010-1234-5678','yu@kh.or.kr');
SELECT * FROM USER_NOCONS;


CREATE TABLE USER_NOTNULL(
    USER_NO NUMBER NOT NULL, --컬럼레벨에서 제약조건 설정
    USER_ID VARCHAR2 (20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

SELECT
    UC.*, UCC.*
FROM SYS.user_constraints UC
JOIN SYS.user_cons_columns UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME 
WHERE UC.TABLE_NAME = 'USER_NOTNULL';
--CONSTRAINT_TYPE 이 'C'인 일종의 CHECK 제약조건이다

INSERT INTO USER_NOTNULL
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01',NULL,'남','010-1234-5678','yu@kh.or.kr');
--UNIQUE 제약 조건 : 컬럼에 입력 값에 대한 중복을 제한하는 제약조건
                --: 컬럼 레벨에서 설정 가능, 테이블 레벨에서 설정 가능
                
                
CREATE TABLE USER_UNIQUE(
    USER_NO NUMBER, 
    USER_ID VARCHAR2 (20) UNIQUE,--컬럼레벨에서 제약조건 설정
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);
INSERT INTO USER_UNIQUE
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01',NULL,'남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01',NULL,'남','010-1234-5678','yu@kh.or.kr');
    
    
SELECT
    UC.*, UCC.*
FROM SYS.user_constraints UC
JOIN SYS.user_cons_columns UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME 
WHERE UCC.CONSTRAINT_NAME = 'SYS_C007048';

CREATE TABLE USER_UNIQUE2(
    USER_NO NUMBER, 
    USER_ID VARCHAR2 (20),
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_ID) --테이블 레벨에서 제약조건 설정
);

INSERT INTO USER_UNIQUE2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,NULL,'pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
SELECT * FROM USER_UNIQUE2;

--두개의 컬럼을 묶어서 하나의 UNIQUE 제약조건 설정
--컬럼 레벨이 아닌 테이블 레벨에서 설정
CREATE TABLE USER_UNIQUE3(
    USER_NO NUMBER, 
    USER_ID VARCHAR2 (20),
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_NO,USER_ID) --테이블 레벨에서 제약조건 설정
);
INSERT INTO USER_UNIQUE3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE3--ORA-00001: unique constraint (EMPLOYEE.SYS_C007052) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user02','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (2,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');

SELECT * FROM USER_UNIQUE3;

--제약 조건명 부여, 지정해주지 않으면 시스템에서 알아서 임의의 제약조건명 부여
-- 제약조건명을 회사의 네이밍 툴에 따르고, 어떤 제약조건이 위배되는 지 한눈에 파악가능

CREATE TABLE CONS_NAME(
    TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL, --NN -0>NOTNULL
    TEST_DATA2 VARCHAR2(20) CONSTRAINT UK_TEST_DATA2 UNIQUE,--UK -> UNIQUE
    TEST_DATA3 VARCHAR2(30) ,
    CONSTRAINT UK_TEST_DATA3 UNIQUE (TEST_DATA3)
);

SELECT *
FROM SYS.USER_CONSTRAINTS
WHERE TABLE_NAME='CONS_NAME';

--CHECK 제약조건 : 컬럼에 기록되는 값에 조건을 설정할 수 있음
--CHECK(컬럼명 비교연산자 비교값)
--주의 : 비교 값은 리터럴만 사용할 수 있음, 변하는 값이나 함수는 사용못함.(자동 NOT NULL규칙이 적용됨)
DROP TABLE USER_CHECK;
CREATE TABLE USER_CHECK(
    USER_NO NUMBER, 
    USER_ID VARCHAR2 (20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_CHECK
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_CHECK--ORA-02290: check constraint (EMPLOYEE.SYS_C007059) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남자','010-1234-5678','yu@kh.or.kr');
    
SELECT
    UC.*, UCC.*
FROM SYS.user_constraints UC
JOIN SYS.user_cons_columns UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME 
WHERE UCC.CONSTRAINT_NAME = 'SYS_C007059';

CREATE TABLE TEST_CHECK(
    TEST_NUMBER NUMBER,
    CONSTRAINT CK_TEST_NUMBER CHECK(TEST_NUMBER>0)
);

INSERT INTO TEST_CHECK
    (TEST_NUMBER)
    VALUES
    (10);
    
INSERT INTO TEST_CHECK --ORA-02290: check constraint (EMPLOYEE.CK_TEST_NUMBER) violated
    (TEST_NUMBER)
    VALUES
    (-10);
    
CREATE TABLE TBL_CHECK(
    C_NAME VARCHAR2(10),
    C_PRICE NUMBER,
    C_LEVEL CHAR (1),
    C_DATE DATE,
    CONSTRAINT CK_C_PRICE CHECK (C_PRIVE >=1 AND C_PRICE <= 9999),
    CONSTRAINT CK_C_LEVEL CHECK (C_LEVEL ='A' OR C_LEVEL ='B' OR C_LEVEL ='C'),
    CONSTRAINT CK_C_DATE CHECK (C_DATE>=TO_DATE('2016/01/01','YYYY/MM/DD'))
);

-- 회원 가입용 테이블 생성(USER_TEST)
-- 컬럼명 : USER_NO(회원번호)
--         USER_ID(회원아이디) -- 중복 금지, NULL값 허용 안함
--         USER_PWD(회원비밀번호) -- NULL값 허용 안함
--         PNO(주민등록번호) -- 중복금지, NULL값 허용 안함
--         GENDER(성별) -- '남' 혹은 '여'로 입력
--         PHONE(연락처)
--         ADDRESS(주소)
--         STATUS(탈퇴여부) -- NOT NULL, 'Y' 혹은 'N'으로 입력

-- 각 컬럼에 제약조건 이름 부여
-- 각 컬럼별로 코멘트 생성
-- 5명 이상 회원 정보 INSERT
drop table user_test;
CREATE TABLE USER_TEST(
    USER_NO NUMBER,
     USER_ID VARCHAR(30) UNIQUE NOT NULL, -- 중복 금지, NULL값 허용 안함
     USER_PWD VARCHAR(30) NOT NULL, -- NULL값 허용 안함
     PNO VARCHAR(30) UNIQUE NOT NULL, -- 중복금지, NULL값 허용 안함
     GENDER CHAR(3) , -- '남' 혹은 '여'로 입력
     PHONE VARCHAR(30),
     ADDRESS VARCHAR(30),
     STATUS CHAR(3) NOT NULL,-- NOT NULL, 'Y' 혹은 'N'으로 입력
     CONSTRAINT C_GENDER CHECK (GENDER IN ('남','여')),
     CONSTRAINT C_STATUS CHECK (STATUS IN ('Y','N'))
);
COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민등록번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '연락처';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';

INSERT INTO USER_TEST
    VALUES (1,'user1','u1','123456-9876452','남','010-1234-1234','서울시 관악구 0동','N');
INSERT INTO USER_TEST
    VALUES (2,'user2','u2','123456-9876453','여','010-1234-1235','서울시 관악구 2동','N');
INSERT INTO USER_TEST
    VALUES (3,'user3','u3','123456-9876454','여','010-1234-1236','서울시 관악구 3동','Y');
INSERT INTO USER_TEST
    VALUES (4,'user4','u4','123456-9876455','남','010-1234-1237','서울시 관악구 4동','N');
INSERT INTO USER_TEST
    VALUES (5,'user5','u5','123456-9876456','남','010-1234-1238','서울시 관악구 5동','Y');
INSERT INTO USER_TEST
    VALUES (6,'user6','u6','123456-9876457','남','010-1234-1239','서울시 관악구 6동','N');

SELECT * FROM USER_TEST;


--PRIMARY KEY(기본키) 제약조건 
-- : 테이블에서 한행의 정보를 찾기위해 사용할 컬럼을 의미
-- 테이블에 대한 식별자 역할을 한다. 
-- NOT NULL+ UNIQUE제약조건의 의미
-- 한 테이블당 한개만 설정
-- 컬럼 레벨, 테이블 레벨 둘다 설정 가능함
-- 한개 컬럼에 설정할수 있고, 여러개 컬럼 묶어서(복합키) 설정 할수 있음 
CREATE TABLE USER_PRIMARYKEY(
    USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY, --컬럼 레벨에서 지정
    USER_ID VARCHAR2 (20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_PRIMARYKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');

INSERT INTO USER_PRIMARYKEY--ORA-00001: unique constraint (EMPLOYEE.PK_USER_NO) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user02','pass02','유재석','남','010-1234-5678','yu@kh.or.kr');

INSERT INTO USER_PRIMARYKEY--ORA-01400: cannot insert NULL into ("EMPLOYEE"."USER_PRIMARYKEY"."USER_NO")
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (NULL,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');

SELECT
    UC.*, UCC.*
FROM SYS.user_constraints UC
JOIN SYS.user_cons_columns UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME 
WHERE UCC.CONSTRAINT_NAME = 'PK_USER_NO';

----
DROP TABLE USER_PRIMARYKEY2;
CREATE TABLE USER_PRIMARYKEY2(
    USER_NO NUMBER ,
    USER_ID VARCHAR2 (20) ,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID) --PK_USER_NO이미 생성되있음
);

INSERT INTO USER_PRIMARYKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_PRIMARYKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (1,'user02','pass02','유재석','남','010-1234-5678','yu@kh.or.kr');
    
INSERT INTO USER_PRIMARYKEY2--ORA-00001: unique constraint (EMPLOYEE.SYS_C007093) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL)
    VALUES
    (2,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr');
    
SELECT *FROM USER_PRIMARYKEY2;

DESC USER_PRIMARYKEY2;

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='MEMBER';

-- FOREIGN KEY(외부키 / 외래키) 제약조건 : 
-- 참조(REFERENCES)된 다른 테이블에서 제공하는 값만 사용할 수 있음
-- 참조 무결성을 위배하지 않게 하기 위해 사용
-- FOREIGN KEY제약조건에 의해서 
-- 테이블간의 관계(RELATIONSHIP)가 형성됨--> JOIN이 가능해짐 
-- 제공되는 값 외에는 NULL을 사용할 수 있음

-- 컬럼레벨일 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 이름] REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]

-- 테이블 레벨일 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할컬럼명) REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]


-- 참조할 테이블의 참조할 컬럼명이 생략되면
-- PRIMARY KEY로 설정된 컬럼이 자동 참조할 컬럼이 됨
-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과,
-- UNIQUE 지정된 컬럼만 외래키로 사용할 수 있음
CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL

);

INSERT INTO USER_GRADE
VALUES(10,'일반회원');

INSERT INTO USER_GRADE
VALUES(20,'우수회원');

INSERT INTO USER_GRADE
VALUES(30,'특별회원');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGNKEY(
    USER_NO NUMBER PRIMARY KEY, --컬럼 레벨에서 지정
    USER_ID VARCHAR2 (20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
    --USER GRADE 테이블의 GRADE_CODE를 참조하겠다.
);

INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (2,'user02','pass02','유재석','남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (3,'user03','pass03','유재석','남','010-1234-5678','yu@kh.or.kr',NULL);

INSERT INTO USER_FOREIGNKEY--ORA-02291: integrity constraint (EMPLOYEE.FK_GRADE_CODE) violated - parent key not found
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (4,'user04','pass04','유재석','남','010-1234-5678','yu@kh.or.kr',50);

INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (5,'user05','pass05','유재석','남','010-1234-5678','yu@kh.or.kr',30);

SELECT
    UC.*, UCC.*
FROM SYS.user_constraints UC
JOIN SYS.user_cons_columns UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME 
WHERE UCC.CONSTRAINT_NAME = 'FK_GRADE_CODE';

SELECT * FROM user_foreignkey;

--USER_FOREIGNKEY 테이블에서 
--회원 아이디, 이름, 성별, 연락처 ,회원등급명을 조회
SELECT
    A.USER_ID,
    A.USER_NAME,
    A.GENDER,
    A.PHONE,
    B.GRADE_NAME
FROM USER_FOREIGNKEY A
--LEFT JOIN USER_GRADE B ON A.GRADE_CODE = B.GRADE_CODE
NATURAL LEFT JOIN USER_GRADE B;


-- 삭제 옵션
--: 부모테이블의 데이터 삭제시 자식 테이블의 데이터를 어떤식으로 처리할지에 대한 내용 설정

DELETE FROM USER_GRADE WHERE GRADE_CODE =10; --ORA-02292: integrity constraint (EMPLOYEE.FK_GRADE_CODE) violated - child record found
--ON DELETE RESTRICTED 기본적으로 지정되어 있음.
--FOREIGN KEY로 지정된 컬럼에서 사용되고 있는 값일 경우, 제공하는 컬럼의 값은 삭제 하지 못함

DELETE FROM USER_GRADE WHERE GRADE_CODE =20;

SELECT * FROM USER_GRADE;


CREATE TABLE USER_GRADE2(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL

);

INSERT INTO USER_GRADE2
VALUES(10,'일반회원');

INSERT INTO USER_GRADE2
VALUES(20,'우수회원');

INSERT INTO USER_GRADE2
VALUES(30,'특별회원');

SELECT * FROM USER_GRADE2;

CREATE TABLE USER_FOREIGNKEY2(
    USER_NO NUMBER PRIMARY KEY, --컬럼 레벨에서 지정
    USER_ID VARCHAR2 (20),
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE2(GRADE_CODE) ON DELETE SET NULL
    --USER GRADE 테이블의 GRADE_CODE를 참조하겠다.
);

INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (1,'user01','pass01','유재석','남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (2,'user02','pass02','유재석','남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (3,'user03','pass03','유재석','남','010-1234-5678','yu@kh.or.kr',NULL);
    
INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,PHONE, EMAIL,GRADE_CODE)
    VALUES
    (4,'user04','pass04','유재석','남','010-1234-5678','yu@kh.or.kr',30);
    
SELECT * FROM USER_FOREIGNKEY2;
SELECT * FROM USER_GRADE2;
DELETE FROM USER_GRADE2 WHERE GRADE_CODE =10;


--ON DELETE CASCADE: 부모키 삭제시 자식행도 삭제
CREATE TABLE USER_GRADE3(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE3
VALUES(10, '일반회원');

INSERT INTO USER_GRADE3
VALUES(20, '우수회원');

INSERT INTO USER_GRADE3
VALUES(30, '특별회원');


CREATE TABLE USER_FOREIGNKEY3(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE, 
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE3(GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGNKEY3 
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (1, 'user01','pass01','유재석', '남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (2, 'user02','pass02','유재석', '남','010-1234-5678','yu@kh.or.kr',10);
    
INSERT INTO USER_FOREIGNKEY3 
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (3, 'user03','pass03','유재석', '남','010-1234-5678','yu@kh.or.kr',NULL);
    
INSERT INTO USER_FOREIGNKEY3 
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (4, 'user04','pass04','유재석', '남','010-1234-5678','yu@kh.or.kr',30);    

SELECT * FROM USER_GRADE3;
SELECT * FROM USER_FOREIGNKEY3;
DELETE FROM USER_GRADE3 WHERE GRADE_CODE = 10;

--서브쿼리를 이용한 테이블 생성(컬럼명, 데이터타입, 값이 복사되고 제약조건은 NOT NULL만 복사됨)
CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;

DROP TABLE EMPLOYEE_COPY;

--구조만 복사할 때
CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE WHERE 1=0; --값이 안나오고 컬럼만

CREATE TABLE EMPLOYEE_COPY2
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
LEFT JOIN JOB USING(JOB_CODE);

--제약조건 추가 
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명 (컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명 비교연산자 비교값)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY (EMP_ID);
ALTER TABLE EMPLOYEE_COPY MODIFY EMP_NAME NOT NULL; --이미 NOT NULL 인 경우 NULL로 변경하고, 다시 NOT NULL로 추가가능




-- 실습
-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조컬럼은 DEPARTMENT의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (DEPT_CODE)REFERENCES DEPARTMENT(DEPT_ID) ON DELETE CASCADE;

-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
ALTER TABLE DEPARTMENT ADD FOREIGN KEY (LOCATION_ID)REFERENCES LOCATION(LOCAL_CODE) ON DELETE CASCADE;

-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB 테이블, 참조 컬럼은 JOB테이블의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (JOB_CODE)REFERENCES JOB(JOB_CODE) ON DELETE CASCADE;

-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조테이블은 SAL_GRADE 테이블, 참조 컬럼은 SAL_GRADE테이블 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (SAL_LEVEL)REFERENCES SAL_GRADE(SAL_LEVEL) ON DELETE CASCADE;

-- EMPLOYEE테이블의 ENT_YN컬럼에 CHECK제약조건 추가('Y','N')
-- 단, 대 소문자를 구분하기 때문에 대문자로 설정
ALTER TABLE EMPLOYEE ADD CHECK (ENT_YN IN ('Y','N'));

-- EMPLOYEE테이블의 SALARY 컬럼에 CHECK제약조건 추가(양수)
ALTER TABLE EMPLOYEE ADD CHECK (SALARY >0);

-- EMPLOYEE테이블의 EMP_NO컬럼에 UNIQUE 제약조건 추가
ALTER TABLE EMPLOYEE MODIFY EMP_NO UNIQUE;
